const validator = require('validator');

const operations = {
  isObject,
  isArray,
  isString,
  isLength
} = require('./lib/operations');
const operationsName = Object.keys(operations);

function viladator() {
  let operationsWithValidation = {};
  let errors = [];
  let currentObject, currentVerification;

  for (let operationName of operationsName) {
    operationsWithValidation[operationName] = function () {
      validation(operationName, arguments[0]);
      return operationsWithValidation;
    }
  }

  this.setObject = function (object) {
    if (isObject(object) || isArray(object)) currentObject = object;
    else throw new Error('Expected object or array but received ' + typeof object);
  };

  this.check = function (str) {
    if (isString(str) && isLength(str, { min: 1 })) {
      if (str.includes('#')) {
        let x = str.split('#');

        if (x.length != 2 || !(x[0] == '' || x[0].endsWith('.')) || x[1] != '') throw new TypeError('Wrong Encoding');
      }

      if (str.includes('*')) {
        let x = str.split('*');

        if ((x[0] != '' && !x[0].endsWith('.')) || (x[x.length - 1] != '' && x[x.length - 1].charAt(0) != '.')) throw new TypeError('Wrong Encoding');

        for (let i = 1; i < (x.length - 1); i++) {
          if (x[i].charAt(0) != '.' || !x[i].endsWith('.')) throw new TypeError('Wrong Encoding');
        }
      }

      if (str != '.' && str.includes('.')) {
        let x = str.split('.');

        for (let i of x) if (i == '') throw new TypeError('Wrong Encoding');
      }

      currentVerification = str;
      return operationsWithValidation;
    } else throw new TypeError('Wrong Encoding');
  };

  this.exist = function (str) {
    if (isString(str) && isLength(str, { min: 1 })) {
      let x;

      try {
        x = eval('currentObject.' + str);
      } catch {
        return false;
      }

      if (x == undefined) return false;
      else return true;
    } else throw new TypeError('Wrong Encoding');
  };

  this.validationErrors = () => errors.length == 0 ? false : errors;

  function pushError(param, value) {
    let equalError = false;

    for (let error of errors) if (error.param == param && (error.value == (value || isString(value) || Number.isNaN(value)) ? value : typeof value)) equalError = true;

    if (!equalError) errors.push({ param: param, value: (value || isString(value) || Number.isNaN(value)) ? value : typeof value });
  }

  function validation(operationName, operationParam) {
    if (currentVerification.includes('#')) {
      let attribute = validator.rtrim(currentVerification.split('#')[0], '.');

      if (attribute.includes('*')) {
        let arrayAttribute = attribute.split('*').map(element => validator.trim(element, '.'));
        let array;

        try {
          array = arrayAttribute[0] == '' ? currentObject : eval('currentObject.' + arrayAttribute[0]);
        } catch {
          pushError(arrayAttribute[0], 'undefined');
          return;
        }

        if (isArray(array)) {
          recursionVerification(array, arrayAttribute, 1, 'key');
        } else {
          pushError(arrayAttribute[0], array);
          return;
        }
      } else {
        let verificationElement;

        try {
          verificationElement = attribute == '' ? currentObject : eval('currentObject.' + attribute);
        } catch {
          pushError(attribute, 'undefined');
          return;
        }

        if (isObject(verificationElement)) {
          for (let key in verificationElement) {
            if (!operations[operationName](key, operationParam)) {
              pushError(attribute == '' ? key : attribute + '.' + key, verificationElement[key]);
            }
          }
        } else {
          pushError(attribute, verificationElement);
          return;
        }
      }
    } else if (currentVerification.includes('*')) {
      let arrayAttribute = currentVerification.split('*').map(element => validator.trim(element, '.'));
      let array;

      try {
        array = arrayAttribute[0] == '' ? currentObject : eval('currentObject.' + arrayAttribute[0]);
      } catch {
        pushError(arrayAttribute[0], 'undefined');
        return;
      }

      if (isArray(array)) {
        recursionVerification(array, arrayAttribute, 1, 'value');
      } else {
        pushError(arrayAttribute[0], array);
        return;
      }
    } else if (currentVerification == '.') {
      if (!operations[operationName](currentObject, operationParam)) throw new Error('Data submitted is invalid');
    } else {
      let verificationElement;

      try {
        verificationElement = eval('currentObject.' + currentVerification);
      } catch {
        pushError(currentVerification, 'undefined');
      }

      if (!operations[operationName](verificationElement, operationParam)) {
        pushError(currentVerification, verificationElement);
      }
    }

    function recursionVerification(array, arrayAttribute, index, option) {
      for (let element of array) {
        if (index == (arrayAttribute.length - 1)) {
          if (option == 'key') {
            if (arrayAttribute[index] == '') {
              for (let key in element) {
                if (!operations[operationName](key, operationParam)) {
                  if (index == 1) {
                    pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + key, element[key]);
                  } else {
                    let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                    for (let k = 1; k < (index - 1); k++) attributeAux = attributeAux + '.' + arrayAttribute[key] + '.*';

                    attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + key;

                    pushError(attributeAux, element[key]);
                  }
                }
              }
            } else {
              let verificationElement;

              try {
                verificationElement = eval('element.' + arrayAttribute[index]);
              } catch {
                if (index == 1) {
                  pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], 'undefined');
                } else {
                  let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                  for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[i] + '.*';

                  attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + arrayAttribute[index];

                  pushError(attributeAux, 'undefined');
                }
              }

              if (isObject(verificationElement)) {
                for (let key in verificationElement) {
                  if (!operations[operationName](key, operationParam)) {
                    if (index == 1) {
                      pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1] + '.' + key, verificationElement[key]);
                    } else {
                      let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                      for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[i] + '.*';

                      if (arrayAttribute[index] == '') {
                        attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + key;
                      } else {
                        attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + arrayAttribute[index] + '.' + key;
                      }

                      pushError(attributeAux, verificationElement[key]);
                    }
                  }
                }
              } else {
                if (index == 1) {
                  pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], element[arrayAttribute[index]]);
                } else {
                  let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                  for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[i] + '.*';

                  attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + arrayAttribute[index];

                  pushError(attributeAux, element[arrayAttribute[index]]);
                }
              }
            }
          } else if (option == 'value') {
            if (arrayAttribute[index] == '') {
              if (!operations[operationName](element, operationParam)) {
                if (index == 1) {
                  pushError(arrayAttribute[0] + '[' + array.indexOf(element) + ']', element);
                } else {
                  let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                  for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[key] + '.*';

                  attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + key;

                  pushError(attributeAux, element[key]);
                }
              }
            } else {
              let verificationElement;

              try {
                verificationElement = eval('element.' + arrayAttribute[index]);
              } catch {
                if (index == 1) {
                  pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], 'undefined');
                } else {
                  let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                  for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[i] + '.*';

                  attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + arrayAttribute[index];

                  pushError(attributeAux, 'undefined');
                }
              }

              if (!operations[operationName](verificationElement, operationParam)) {
                if (index == 1) {
                  pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], verificationElement);
                } else {
                  let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

                  for (let i = 1; i < (index - 1); i++) attributeAux = attributeAux + '.' + arrayAttribute[i] + '.*';

                  if (arrayAttribute[index] == '') {
                    attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + ']';
                  } else {
                    attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + array.indexOf(element) + '].' + arrayAttribute[index];
                  }

                  pushError(attributeAux, verificationElement);
                }
              }
            }
          }
        } else {
          let verificationElement;

          try {
            verificationElement = eval('element.' + arrayAttribute[index]);
          } catch {
            if (index == 1) {
              pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], 'undefined');
            } else {
              let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

              for (let j = 1; j < (index - 1); j++) attributeAux = attributeAux + '.' + arrayAttribute[j] + '.*';

              attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + i + '].' + arrayAttribute[index];

              pushError(attributeAux, 'undefined');
            }
          }

          if (isArray(verificationElement)) {
            recursionVerification(verificationElement, arrayAttribute, index + 1, option);
          } else {
            if (index == 1) {
              pushError(arrayAttribute[0] + '[' + array.indexOf(element) + '].' + arrayAttribute[1], verificationElement);
            } else {
              let attributeAux = arrayAttribute[0] == '' ? '*' : arrayAttribute[0] + '.*';

              for (let j = 1; j < (index - 1); j++) attributeAux = attributeAux + '.' + arrayAttribute[j] + '.*';

              attributeAux = attributeAux + '.' + arrayAttribute[index - 1] + '[' + i + '].' + arrayAttribute[index];

              pushError(attributeAux, verificationElement);
            }
          }
        }
      }
    }
  }
}

viladator.prototype.toDate = operations.toDate;
viladator.prototype.toFloat = operations.toFloat;
viladator.prototype.toInt = operations.toInt;
viladator.prototype.toBoolean = operations.toBoolean;
viladator.prototype.equals = operations.equals;
viladator.prototype.contains = operations.contains;
viladator.prototype.matches = operations.matches;
viladator.prototype.isEmail = operations.isEmail;
viladator.prototype.isURL = operations.isURL;
viladator.prototype.isMACAddress = operations.isMACAddress;
viladator.prototype.isIP = operations.isIP;
viladator.prototype.isIPRange = operations.isIPRange;
viladator.prototype.isFQDN = operations.isFQDN;
viladator.prototype.isBoolean = operations.isBoolean;
viladator.prototype.isAlpha = operations.isAlpha;
viladator.prototype.isAlphanumeric = operations.isAlphanumeric;
viladator.prototype.isNumeric = operations.isNumeric;
viladator.prototype.isPort = operations.isPort;
viladator.prototype.isLowercase = operations.isLowercase;
viladator.prototype.isUppercase = operations.isUppercase;
viladator.prototype.isAscii = operations.isAscii;
viladator.prototype.isFullWidth = operations.isFullWidth;
viladator.prototype.isHalfWidth = operations.isHalfWidth;
viladator.prototype.isVariableWidth = operations.isVariableWidth;
viladator.prototype.isMultibyte = operations.isMultibyte;
viladator.prototype.isSurrogatePair = operations.isSurrogatePair;
viladator.prototype.isInt = operations.isInt;
viladator.prototype.isFloat = operations.isFloat;
viladator.prototype.isDecimal = operations.isDecimal;
viladator.prototype.isHexadecimal = operations.isHexadecimal;
viladator.prototype.isDivisibleBy = operations.isDivisibleBy;
viladator.prototype.isHexColor = operations.isHexColor;
viladator.prototype.isISRC = operations.isISRC;
viladator.prototype.isMD5 = operations.isMD5;
viladator.prototype.isHash = operations.isHash;
viladator.prototype.isJWT = operations.isJWT;
viladator.prototype.isJSON = operations.isJSON;
viladator.prototype.isEmpty = operations.isEmpty;
viladator.prototype.isByteLength = operations.isByteLength;
viladator.prototype.isUUID = operations.isUUID;
viladator.prototype.isMongoId = operations.isMongoId;
viladator.prototype.isAfter = operations.isAfter;
viladator.prototype.isBefore = operations.isBefore;
viladator.prototype.isIn = operations.isIn;
viladator.prototype.isCreditCard = operations.isCreditCard;
viladator.prototype.isIdentityCard = operations.isIdentityCard;
viladator.prototype.isISIN = operations.isISIN;
viladator.prototype.isISBN = operations.isISBN;
viladator.prototype.isISSN = operations.isISSN;
viladator.prototype.isMobilePhone = operations.isMobilePhone;
viladator.prototype.isPostalCode = operations.isPostalCode;
viladator.prototype.isCurrency = operations.isCurrency;
viladator.prototype.isISO8601 = operations.isISO8601;
viladator.prototype.isRFC3339 = operations.isRFC3339;
viladator.prototype.isISO31661Alpha2 = operations.isISO31661Alpha2;
viladator.prototype.isISO31661Alpha3 = operations.isISO31661Alpha3;
viladator.prototype.isBase64 = operations.isBase64;
viladator.prototype.isDataURI = operations.isDataURI;
viladator.prototype.isMagnetURI = operations.isMagnetURI;
viladator.prototype.isMimeType = operations.isMimeType;
viladator.prototype.isLatLong = operations.isLatLong;
viladator.prototype.ltrim = operations.ltrim;
viladator.prototype.rtrim = operations.rtrim;
viladator.prototype.trim = operations.trim;
viladator.prototype.escape = operations.escape;
viladator.prototype.unescape = operations.unescape;
viladator.prototype.stripLow = operations.stripLow;
viladator.prototype.whitelist = operations.whitelist;
viladator.prototype.blacklist = operations.blacklist;
viladator.prototype.isWhitelisted = operations.isWhitelisted;
viladator.prototype.normalizeEmail = operations.normalizeEmail;
viladator.prototype.isArray = operations.isArray;
viladator.prototype.isDate = operations.isDate;
viladator.prototype.isLength = operations.isLength;
viladator.prototype.isObject = operations.isObject;
viladator.prototype.isRegExp = operations.isRegExp;
viladator.prototype.isString = operations.isString;

module.exports = viladator;
